#include <cmath> namespace std  안에서 정의됨
ceil // 반올림 
floor// 내림
floor(N + 0.5);  //반올림 


	cin.tie(NULL);
	ios_base::sync_with_stdio(false);


#for문안에서,,,
for(int i = 0 ; i<s.length();i++) 
// 이런거 할떄 s.length() 조심해야함 +(안에서 길이가 변할경우 ...) 

#include <algorithm>
        reverse
        sort
        -sort(start,end)
        -sort(start,end,compare)
        -sort(start,end,grearter<자료형>())

        unique
                vector<int> v = { 1, 2, 3, 1, 2 }; 
                sort(v.begin(), v.end()); 
                        //unique(v.begin(), v.end());
                        //주석 풀면 답 틀림. unique는 제일 처음 나오는 쓰레기 값의 iterator를 반환.
                v.erase(unique(v.begin(), v.end()),v.end()); //1,2,3


#비트연산 
for(int i=0; i<n; i++)
        arr1[i] |= arr2[i]; -->or연산  00110010 |= 10101010 -->10111010
--> 지도 문제

#include <cctype> //C++ --> 근데 없어도 작동하는듯...
toupper // 문자 만 바꾸고 아닌건 그대로 리턴.... error X
tolower


#pair (queue등과의 활용이 아닌 단독 pair-->#include <utility> )
pair<int, string> p;
p.first = 1;
p.second = "choiiis";
cout<<p.first<<" "<< p.second; //OK

pair<int, string> p = make_pair(1,"choiiis");

#pair 복사 생성
pair<int, string> p1(1, "choiiis");
pair<int, string> p2=p1; //OK
pair<int, string> p2(p1); //OK


*이상한 min max -->고정값을 넘어야함 ...
#include <string>
#include <iostream>
using namespace std;

*(A+B)%C == ( (A%C)+(B%C) ) %C;


int main(void) {
	string s = "abcabcabcabcdededededede";
    	int answer = 10;
   	 answer=min(answer , s.length()); // 랙처먹음 
	//int len = s.length(); 하고 len을 넣어주면 또 됨.... 
   	 cout<<answer<<endl;
    
   	 return 0;
}
	

//주식문제 

stack에다 값이 아닌 인덱스 쌓기